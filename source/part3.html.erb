---
  title: Osa 3
  exercise_page: true
  quiz_page: true
  published: false
---


<% partial 'partials/hint', locals: { name: 'Kolmannen osan oppimistavoitteet' } do %>

  <p>
    Tuntee luokkakaavioissa esiintyvät assosiaatiot yhden suhde yhteen, yhden suhde moneen ja monen suhde moneen. Osaa luoda annetusta luokkakaaviosta relaatiokaavion, ja osaa muuntaa luokkakaavion assosiaatiot tarvittaessa tietokannalle sopivampaan muotoon. Tuntee käsitteet pääavain ja viiteavain. Osaa luoda SQL-kielellä useampia tietokantatauluja sisältävän tietokannan, lisätä tietokantaan tietoa, ja tehdä tietokantaan kyselyitä. Osaa hakea useammasta tietokantataulusta tietoa JOIN-kyselyiden avulla. Osaa luoda ohjelman, joka hyödyntää useamman tietokantataulun sisältävää tietokantaa ja tuntee data access object (DAO) -suunnittelumallin.
  </p>
  
<% end %>



<% partial 'partials/material_heading' do %>
  Tiedon hakeminen kahdesta tai useammasta taulusta
<% end %>


<p>
  Edellisissä luvuissa loimme luokkakaavion pohjalta relaatiokaavion, jonka pohjalta loimme tietokantataulujen luomiseen tarvittavat kyselyt. Tutustuimme kurssin edellisessä osassa SQL-kyselyihin, joiden avulla mm. haimme tietoa yksittäisestä tietokantataulusta. Tutustutaan seuraavaksi tiedon hakemiseen useammasta taulusta.
</p>

<p>
  Edellisen osan pohjalta muistamme, että SELECT-lauseen avainsanaa <code>FROM</code> seuraa taulu, josta tietoa haetaan. Voimme määritellä haun kohteeksi useampia tauluja listaamalla ne FROM-avainsanan jälkeen pilkulla eroteltuna seuraavasti <code>SELECT * FROM Asiakas, Tilaus</code>. Jos emme kerro miten taulujen rivit yhdistetään, on lopputuloksessa kaikki rivit yhdistettynä kaikkiin riveihin -- esimerkiksi jokainen taulun Asiakas rivi yhdistettynä jokaiseen taulun Tilaus riviin.
</p>

<p>
  Tällainen lopputulos ei ole tyypillisesti tavoiteltu -- kyselyn tulostaulu listaa jokaiseen asiakkaaseen kytkettynä jokaisen tilauksen, jolloin todellista tietoa siitä, kenen mikäkin tilaus oli ei ole.
</p>

<p>
  Taulujen yhdistäminen tapahtuu kyselyä rajaavan <code>WHERE</code>-ehdon avulla siten, että taulun pääavainta verrataan siihen viittaavan taulun viiteavaimeen. Esimerkiksi, jos haluamme vain asiakkaat sekä asiakkaaseen liittyvät tilaukset, hyödynnämme Asiakas-taulun pääavainta id sekä Tilaus-taulun viiteavainta asiakas_id, joka viittaa Asiakas-taulun pääavaimeen. Käytännössä tämä tapahtuu ehdolla <code>WHERE Asiakas.id = Tilaus.asiakas_id</code>.
</p>

<p>
  Kokonaisuudessaan lause "Listaa jokaisen asiakkaan tekemät tilaukset" kirjoitetaan seuraavasti: <code>SELECT * FROM Asiakas, Tilaus WHERE Asiakas.id = Tilaus.asiakas_id</code>.
</p>


<% partial 'partials/material_sub_heading' do %>
  Tulosten nimeäminen
<% end %>

<p>
  Useamman taulun yhdistäminen onnistuu samalla tavalla. Kaikki taulut, jotka haluamme lisätä kyselyyn, tulevat FROM-avainsanan jälkeen. Jos tauluja on useampi, on hyvä varmistaa, että kaikki taulut yhdistetään avainkenttien perusteella.
</p>

<p>
  Kun yhdistämme useampia tauluja, päädymme helposti tilanteeseen, missä tuloksessa on myös useampia samannimisiä kenttiä. Esimerkiksi tilaustietokannassa taulut Asiakas, Ravintola, Annos ja RaakaAine kukin sisältää attribuutin nimi. Voimme määritellä taulun, mihin haettava kenttä liittyy, pisteoperaattorin avulla. Kyselyn <code>SELECT nimi FROM Asiakas</code> voi siis kirjoittaa myös muodossa <code>SELECT Asiakas.nimi FROM Asiakas</code>.
</p>

<p>
  Voimme toisaalta myös nimetä kentän tulostusmuodon seuraavasti <code>SELECT Asiakas.nimi AS asiakas FROM Asiakas</code>. Edelläoleva kysely hakee Asiakas-taulusta asiakkaan nimen, mutta tulostaa nimet otsikolla 'asiakas'.
</p>

<p>
  Alla oleva kysely listaa asiakkaan sekä kaikki asiakkaan tilauksissa olleet annokset. Huomaa, että jokainen annos tulee omalle rivilleen.
</p>


<% partial 'partials/sql_highlight' do %>
  SELECT Asiakas.nimi AS asiakas, Annos.nimi AS annos
      FROM Asiakas, Tilaus, TilausAnnos, Annos
      WHERE Asiakas.id = Tilaus.asiakas_id
          AND TilausAnnos.tilaus_id = Tilaus.id
          AND Annos.id = TilausAnnos.annos_id;
<% end %>



<% partial 'partials/material_sub_heading' do %>
  Taulujen yhdistämisestä
<% end %>

<p>
  Jotta tietokantakysely tulostaa oleelliset rivit, on jokainen kyselyyn lisättävä taulu kytkettävä toisiinsa. Eräs hyödyllinen tapa taulujen yhdistämiseen tarvittujen kyselyjen hahmottamiseen on tietokantakaavion katsominen. Jos tavoitteena olisi esimerkiksi etsiä kaikki raaka-aineet, mitä Leevi-niminen asiakas on saattanut syödä, ensimmäinen askel on etsiä polku taulusta <code>Asiakas</code> tauluun <code>RaakaAine</code>.
</p>
  
<p>
  Aloitamme taulusta <code>Asiakas</code> ja etsimme polkua tauluun <code>RaakaAine</code>. Jotta pääsemme taulusta Asiakas tauluun RaakaAine, tulee meidän vierailla tauluissa <code>TilausAnnos</code>, <code>Annos</code> ja <code>AnnosRaakaAine</code>.
</p>

<p>
  
</p>
  
<ol>
  <li>
    Haemme aluksi asiakkaan nimeltä Leevi.

    <pre class="sh_sql">
SELECT Asiakas.nimi AS asiakas
    FROM Asiakas
    WHERE Asiakas.nimi = 'Leevi';
    </pre>
  </li>


  <li>
    Kytketään tähän seuraavaksi kaikki Leevin tekemät tilaukset.

    <pre class="sh_sql">
SELECT Asiakas.nimi AS asiakas
    FROM Asiakas, Tilaus
    WHERE Asiakas.nimi = 'Leevi'
        AND Tilaus.asiakas_id = Asiakas.id;
    </pre>
  </li>

  
  <li>
    Yhdistämme edelliseen kyselyyn taulun TilausAnnos.

    <pre class="sh_sql">
SELECT Asiakas.nimi AS asiakas
    FROM Asiakas, Tilaus, TilausAnnos
    WHERE Asiakas.nimi = 'Leevi'
        AND Tilaus.asiakas_id = Asiakas.id
        AND TilausAnnos.tilaus_id = Tilaus.id;
    </pre>
  </li>
  
  
  <li>
    Yhdistämme edelliseen kyselyyn taulun Annos.

    <pre class="sh_sql">
SELECT Asiakas.nimi AS asiakas
    FROM Asiakas, Tilaus, TilausAnnos, Annos
    WHERE Asiakas.nimi = 'Leevi'
        AND Tilaus.asiakas_id = Asiakas.id
        AND TilausAnnos.tilaus_id = Tilaus.id
        AND Annos.id = TilausAnnos.annos_id;
    </pre>
  </li>

  <li>
    Yhdistämme edelliseen kyselyyn taulun AnnosRaakaAine.

    <pre class="sh_sql">
SELECT Asiakas.nimi AS asiakas
    FROM Asiakas, Tilaus, TilausAnnos, Annos, AnnosRaakaAine
    WHERE Asiakas.nimi = 'Leevi'
        AND Tilaus.asiakas_id = Asiakas.id
        AND TilausAnnos.tilaus_id = Tilaus.id
        AND Annos.id = TilausAnnos.annos_id
        AND AnnosRaakaAine.annos_id = Annos.id;
    </pre>
  </li>
  

  <li>
    Yhdistämme edelliseen kyselyyn taulun RaakaAine.

    <pre class="sh_sql">
SELECT Asiakas.nimi AS asiakas
    FROM Asiakas, Tilaus, TilausAnnos, Annos, AnnosRaakaAine, RaakaAine
    WHERE Asiakas.nimi = 'Leevi'
        AND Tilaus.asiakas_id = Asiakas.id
        AND TilausAnnos.tilaus_id = Tilaus.id
        AND Annos.id = TilausAnnos.annos_id
        AND AnnosRaakaAine.annos_id = Annos.id
        AND RaakaAine.id = AnnosRaakaAine.raaka_aine_id;
    </pre>
  </li>


  <li>
    Lopulta lisäämme raaka-aineen nimien SELECT-komentoon.

    <pre class="sh_sql">
SELECT Asiakas.nimi AS asiakas, RaakaAine.nimi AS raaka_aine
    FROM Asiakas, Tilaus, TilausAnnos, Annos, AnnosRaakaAine, RaakaAine
    WHERE Asiakas.nimi = 'Leevi'
        AND Tilaus.asiakas_id = Asiakas.id
        AND TilausAnnos.tilaus_id = Tilaus.id
        AND Annos.id = TilausAnnos.annos_id
        AND AnnosRaakaAine.annos_id = Annos.id
        AND RaakaAine.id = AnnosRaakaAine.raaka_aine_id;
    </pre>
  </li>
</ol>
  
  


<% partial 'partials/material_sub_heading' do %>
  Taulujen yhdistämisestä JOIN-kyselyillä
<% end %>


<p>
  Kyselyssä, missä taulujen rivit yhdistetään WHERE-ehdon ja avainten perusteella, valitaan näytettäväksi vain ne rivit, jotka täyttävät annetun ehdon. Entä jos haluaisimme nähdä myös ne kurssit, joita kukaan ei ole suorittanut? Tämä ei ole suoraviivaista WHERE-ehdon kautta rakennetun kyselyn avulla.
</p>

<p>
  Vuonna 1992 julkaistu SQL-standardin versio toi mukanaan JOIN-kyselyt, joiden avulla edellä määritelty ongelma ratkeaa -- pienen harjoittelun kautta. Tutustutaan seuraavaksi aiemmin oppimaamme taulujen yhdistämistapaa tukeviin erityyppisiin JOIN-kyselyihin.
</p>


<% partial 'partials/material_sub_heading' do %>
  INNER JOIN
<% end %>

<p>
  Edellä tutuksi tullut kysely <code>SELECT * FROM Asiakas, Tilaus WHERE Asiakas.id = Tilaus.asiakas_id</code> valitsee vastaukseen vain ne rivit, joiden kohdalla ehto <em>Asiakas.id = Tilaus.asiakas_id</em> pätee, eli missä Asiakkaan id-sarakkeen (pääavaimen) arvo on sama kuin Tilaus-taulun asiakas_id-sarakkeen (viiteavain).
</p>

<p>
  Edellinen kysely voidaan kirjoittaa myös muodossa <code>SELECT * FROM Asiakas INNER JOIN Tilaus ON Asiakas.id = Tilaus.asiakas_id</code>.
</p>

<p>
  Jos haluamme kyselyyn useampia tauluja, lisätään ne INNER JOIN -komennon avulla kyselyn jatkoksi. Esimerkiksi kaksi seuraavaa kyselyä ovat toiminnallisuudeltaan samankaltaiset.
</p>

<pre class="sh_sql">
SELECT Asiakas.nimi AS asiakas, Tilaus.aika AS tilausaika, Annos.nimi AS annos
    FROM Asiakas, Tilaus, TilausAnnos, Annos
    WHERE Asiakas.id = Tilaus.asiakas_id
        AND TilausAnnos.tilaus_id = Tilaus.id
        AND Annos.id = TilausAnnos.annos_id;
</pre>


<pre class="sh_sql">
SELECT Asiakas.nimi AS asiakas, Tilaus.aika AS tilausaika, Annos.nimi AS annos
    FROM Asiakas
    INNER JOIN Tilaus ON Asiakas.id = Tilaus.asiakas_id
    INNER JOIN TilausAnnos ON TilausAnnos.tilaus_id = Tilaus.id
    INNER JOIN Annos ON Annos.id = TilausAnnos.annos_id
</pre>

<p>
  Kyselyn <em>INNER JOIN</em> avulla voimme siis tehdä kutakuinkin saman työn kuin aiemman WHERE-ehdon avulla, eli valita mukaan vain ne rivit, joiden kohdalla ehto pätee.
</p>


<% partial 'partials/material_sub_heading' do %>
  LEFT JOIN
<% end %>

<p>
  Mikä tekee taulujen liitoksesta JOIN-kyselyn avulla WHERE-ehtoa monipuolisemman, on se, että JOIN-kyselyn avulla voidaan määritellä kyselyehtoa täyttämättömille riveille toiminnallisuutta. Avainsanalla <code>LEFT JOIN</code> voidaan määritellä kyselyn tulos sellaiseksi, että ehdon täyttävien rivien lisäksi vastaukseen sisällytetään kaikki FROM-avainsanaa seuraavan taulun rivit, joille liitosehto ei täyttynyt.
</p>

<p>
  Allaoleva kysely listaa tilauksia tehneiden asiakkaiden lisäksi myös ne asiakkaat, joilla ei ole yhtäkään tilausta. Tällöin tilaukseen liittyvä vastauksen osa jää tyhjäksi.
</p>


<pre class="sh_sql">
SELECT Asiakas.nimi AS asiakas, Tilaus.aika AS tilausaika
    FROM Asiakas
    LEFT JOIN Tilaus ON Asiakas.id = Tilaus.asiakas_id
</pre>



<% partial 'partials/material_sub_heading' do %>
  Liitostyypit lyhyesti
<% end %>

<p>
  Kyselyn JOIN-tyypin voi muotoilla usealla eri tavalla:
</p>

<ul>
  <li>
    <code>INNER JOIN</code> -- palauta vain ne rivit, joihin valintaehto kohdistuu.
  </li>
  <li>
    <code>LEFT JOIN</code> -- palauta kaikki FROM-komentoa seuraavan taulun rivit, ja liitä niihin LEFT JOIN-komentoa seuraavan taulun rivit niiltä kohdin, kuin se on ON-liitosehdossa määritellyn ehdon mukaan mahdollista
  </li>
  <li>
    <code>RIGHT JOIN</code> -- palauta kaikki RIGHT JOIN-komentoa seuraavan taulun rivit, ja liitä niihin FROM-komentoa seuraavan taulun rivit niiltä kohdin, kuin se on ON-liitosehdossa määritellyn ehdon mukaan mahdollista
  </li>
  <li>
    <code>FULL JOIN</code> -- palauta kaikki FROM-komentoa seuraavan taulun rivit sekä kaikki FULL JOIN-komentoa seuraavan taulun rivit, ja liitä ne toisiinsa niiltä kohdin, kuin se on ON-liitosehdossa määritellyn ehdon mukaan mahdollista
  </li>
</ul>

<p>
  <em>Valitettavasti SQLite ei tue RIGHT JOIN ja FULL JOIN -tyyppisiä kyselyitä.</em>
</p>


<% partial 'partials/hint', locals: { name: 'Visuaalinen opas JOIN-kyselyihin' } do %>
  
  <p>
    C.L. Moffatt on kirjoittanut hyvän yhteenvedon erilaisista JOIN-tyypeistä. Tutustu yhteenvetoon osoitteessa <a href="http://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins" target="_blank">http://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins</a>.
  </p>
  
  <figure>
    <img src="/img/viikko3/moffatt-visual_joins.png"/>
    <p>&nbsp;</p>
    <figcaption>Yhteenveto erilaisista JOIN-kyselyistä ja niiden merkityksistä joukkojen kautta visualisoituna.</figcaption>
  </figure>

<% end %>



<% partial 'partials/exercise', locals: { name: 'Kyselyjä' } do %>

  <p>
    Tehtäväpohjan kansiossa <code>db</code> tulee tiedosto nimeltä <code>Chinook_Sqlite.sqlite</code>. Avaa tiedosto SQLiten avulla. Kun tietokanta on avattu oikein, komento .tables antaa seuraavanlaisen tulostuksen.
  </p>

  <pre>
  sqlite&gt; .tables
  Album          	Employee       	InvoiceLine    	PlaylistTrack
  Artist         	Genre          	MediaType      Track        
  Customer       	Invoice        	Playlist     
  </pre>

  <p>
    Kuten taulujen nimistä voi arvata, tietokanta kuvaa digitaalisen musiikin myyntipalvelua. Tietokannan relaatiokaavio löytyy osoitteesta <a href="http://chinookdatabase.codeplex.com/wikipage?title=Chinook_Schema&referringTitle=Documentation" target="_blank" norel>http://chinookdatabase.codeplex.com/wikipage?title=Chinook_Schema&referringTitle=Documentation</a>. Kirjoita SQLiten avulla kyselyt, joilla saa selville seuraavat tiedot.
  </p>

  <ul>
    <li>Kysely 1: Listaa artistit, jotka soittavat Blues-musiikkia.</li>
    <li>Kysely 2: Listaa soittolistat (playlist), joilla Eric Clapton esiintyy.</li>
    <li>Kysely 3: Listaa sähköpostiosoitteet niiltä asiakkailta, jotka ovat ostaneet Jazz-musiikkia.</li>
  </ul>

  <p>
    Kun olet saanut kyselyt toimimaan, kopioi ne tehtäväpohjassa olevan luokan Kyselyja metodeihin kysely1, kysely2 ja kysely3.
  </p>
  
<% end %>



<% partial 'partials/material_heading' do %>
  Tietokannan käsittely ohjelmallisesti
<% end %>

<p>
  Lähes jokainen ohjelmointikieli tarjoaa jonkinlaisen rajapinnan tietokantakyselyiden tekemiseen. Nämä rajapinnat suoraviivaistavat kyselyiden tekemistä tietokantoihin ja tietokannanhallintajärjestelmien käyttöönoottoa, sillä rajapintaa noudattamalla yhteydenotto tietokannantallintajärjestelmään on lähes samankaltaista käytetystä tietokannanhallintajärjestelmästä riippumatta.
</p>

<p>
  Java-kielessä tähän tehtävään on <a href="https://en.wikipedia.org/wiki/Java_Database_Connectivity" target="_blank" nodel>Java Database Connectivity</a> (JDBC) -rajapinta. JDBC tarjoaa tuen tietokantayhteyden luomiseen sekä kyselyiden suorittamiseen tietokantayhteyden yli. Jotta JDBCn avulla voidaan ottaa yhteys tietokantaan, tulee käytössä olla tietokannanhallintajärjestelmäkohtainen ajuri, jonka vastuulla on tietokantayhteyden luomiseen liittyvät yksityiskohdat sekä tietokannanhallintajärjestelmän sisäisten kyselytulosten muuntaminen JDBC-rajapinnan mukaiseen muotoon.
</p>


<% partial 'partials/hint', locals: { name: 'JDBC-ajurin noutaminen' } do %>
  
  <p>
    JDBC-ajurit ovat käytännössä Java-kielellä kirjoitettuja ohjelmia, joita tietokannanhallintajärjestelmän toteuttajat tarjoavat ohjelmoijien käyttöön. Kurssin toisessa osassa ajurit on lisätty valmiiksi tehtäväpohjien <code>lib</code>-kansioon, jonka lisäksi niiden käyttö on valmiiksi määritelty tehtäväpohjissa.
  </p>

  <p>
    Myöhemmissä osissa tutustumme kirjastojen käyttöönottoon ja hakemiseen <a href="https://maven.apache.org/" target="_blank" norel">Maven</a>-apuvälineen avulla.
  </p>
  
<% end %>



<% partial 'partials/material_sub_heading' do %>
  Ohjelmallinen tietokantakysely kokonaisuudessaan 
<% end %>


<p>
  Oletetaan, että käytössämme on seuraava tietokantataulu Opiskelija:
</p>

<table class="table">
  <thead>
    <tr>
      <th>opiskelijanumero (integer)</th>
      <th>nimi (varchar)</th>
      <th>syntymävuosi (integer)</th>
      <th>pääaine (varchar)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>9999999</td>
      <td>Pihla</td>
      <td>1997</td>
      <td>Tietojenkäsittelytiede</td>
    </tr>
    <tr>
      <td>9999998</td>
      <td>Joni</td>
      <td>1993</td>
      <td>Tietojenkäsittelytiede</td>
    </tr>
    <tr>
      <td>...</td>
      <td></td>
      <td></td>
      <td></td>
    </tr>
  </tbody>
</table>


<p>
  JDBCn avulla kyselyn tekeminen tietokantatauluun tapahtuu seuraavasti -- olettaen, että käytössämme on sekä tietokanta, että tietokannan ajuri.
</p>


<% partial 'partials/code_highlight' do %>
  import java.sql.Connection;
  import java.sql.DriverManager;
  import java.sql.ResultSet;
  import java.sql.Statement;

  public class Main {
  public static void main(String[] args) throws Exception {
  // luodaan yhteys jdbc:n yli sqlite-tietokantaan nimeltä "tietokanta.db"
  Connection connection = DriverManager.getConnection("jdbc:sqlite:tietokanta.db");

  // luodaan kyely "SELECT * FROM Opiskelija", jolla haetaan
  // kaikki tiedot Opiskelija-taulusta
  PreparedStatement statement = connection.prepareStatement("SELECT * FROM Opiskelija");

  // suoritetaan kysely -- tuloksena resultSet-olio
  ResultSet resultSet = statement.executeQuery();

  // käydään tuloksena saadussa oliossa olevat rivit läpi -- next-komento hakee
  // aina seuraavan rivin, ja palauttaa true jos rivi löytyi
  while(resultSet.next()) {
  // haetaan nykyiseltä riviltä opiskelijanumero int-muodossa
  Integer opNro = resultSet.getInt("opiskelijanumero");
  // haetaan nykyiseltä riviltä nimi String-muodossa
  String nimi = resultSet.getString("nimi");
  // haetaan nykyiseltä riviltä syntymävuosi int-muodossa
  Integer syntVuosi = resultSet.getInt("syntymävuosi");
  // haetaan nykyiseltä riviltä pääaine String-muodossa
  String paaAine = resultSet.getString("pääaine");

  // tulostetaan tiedot
  System.out.println(opNro + "\t" + nimi + "\t" + syntVuosi + "\t" + paaAine);
  }

  // suljetaan lopulta yhteys tietokantaan
  connection.close();
  }
  }
<% end %>

<p>
  Ohjelman suoritus tuottaa (esimerkiksi) seuraavanlaisen tulostuksen:
</p>

<% partial 'partials/sample_output' do %>
  999999	Pihla	1997	Tietojenkäsittelytiede
  999998	Joni	1993	Tietojenkäsittelytiede
  999997	Anna	1991	Matematiikka
  999996	Krista	1990	Tietojenkäsittelytiede
  ...
<% end %>


<% partial 'partials/material_sub_heading' do %>
  Ohjelman rakentaminen osissa 
<% end %>

<p>
  <em>Tässä oletetaan, että projektiin on lisätty tarvittava JDBC-ajuri.</em>
</p>

<p>
  Avaa projektiin liittyvä <em>Source Packages</em> ja valitse (tai tarvittaessa luo) sopiva pakkaus. Oletetaan tässä, että käytössä on pakkaus <code>tikape</code>. Valitse tämän jälkeen <em>New</em> -> <em>Java Class</em>, jonka jälkeen avautuu valikko, missä voit antaa luokalle nimen. Anna luokan nimeksi <code>Main</code>.
</p>

<p>
  Avaa tiedosto tuplaklikkaamalla sitä. Muokkaa tiedostoa vielä siten, että se on seuraavan näköinen:
</p>

<% partial 'partials/code_highlight' do %>
  package tikape;

  public class Main {

  public static void main(String[] args) throws Exception {

  }
  }
<% end %>



<% partial 'partials/material_sub_sub_heading' do %>
  Tietokantayhteyden luominen
<% end %>

<p>
  Lisää projektiin <em>import</em>-komento <code>import java.sql.*;</code>, joka hakee kaikki SQL-kyselyihin liittyvät Javan kirjastot.
</p>

<% partial 'partials/code_highlight' do %>
  package tikape;

  import java.sql.*;

  public class Main {

  public static void main(String[] args) throws Exception {

  }
  }
<% end %>

<p>
  Avataan seuraavaksi tietokantayhteys tietokantatiedostoon nimeltä <em>testi.db</em> ja tehdään kysely "SELECT 1", jolla pyydetään tietokantaa palauttamaan luku 1 -- käytämme tätä yhteyden testaamiseksi. Jos yhteyden luominen onnistuu, tulostetaan "Hei tietokantamaailma!", muulloin "Yhteyden muodostaminen epäonnistui".
</p>

<% partial 'partials/code_highlight' do %>
  package tikape;

  import java.sql.*;

  public class Main {

  public static void main(String[] args) throws Exception {
  Connection connection = DriverManager.getConnection("jdbc:sqlite:testi.db");

  PreparedStatement statement = connection.prepareStatement("SELECT 1");

  ResultSet resultSet = statement.executeQuery();

  if(resultSet.next()) {
  System.out.println("Hei tietokantamaailma!");
  } else {
  System.out.println("Yhteyden muodostaminen epäonnistui.");
  }
  }
  }
<% end %>

<% partial 'partials/sample_output' do %>
  Hei tietokantamaailma!
<% end %>

<p>
  Kun suoritamme ohjelman ensimmäistä kertaa valitsemalla <em>Run</em> -> <em>Run Project</em>, puuttuvan tietokannan paikalle luodaan tietokanta (ainakin SQLiteä käyttäessä). Projektin kansiossa on nyt tiedosto <code>testi.db</code>, joka on tietokantamme.
</p>


<figure>
  <img src="img/viikko3/nb-testidb.png" alt="Kun ohjelma on suoritettu ensimmäistä kertaa, tiedosto testi.db luodaan projektiin."/>
  <figcaption>Tietokantatiedosto <em>testi.db</em> löytyy projektin kansiosta. Tiedostot löytyvät <em>Files</em>-välilehdeltä.</figcaption>
</figure>



<% partial 'partials/material_sub_sub_heading' do %>
  Tietokantakyselyiden tekeminen
<% end %>

<p>
  Osoitteessa <a href="https://materiaalit.github.io/tikape-s17/dbs/vuokraamo.db">vuokraamo.db</a> löytyy kuvitteellisen moottoripyörävuokraamon tietokanta. Lataa se edellä tehdyn projektin juureen ja kokeile kyselyn tekemistä kyseiseen tietokantaan.
</p>

<p>
  Tietokannassa on tietokantataulu <code>Pyora</code>, jolla on sarakkeet <code>rekisterinumero</code> ja <code>merkki</code>. Jokaisen pyörän rekisterinumeron ja merkin tulostaminen tapahtuu seuraavasti -- huomaa myös, että olemme vaihtaneet käytössä olevaa tietokantaa.
</p>

<% partial 'partials/code_highlight' do %>
  Connection connection = DriverManager.getConnection("jdbc:sqlite:vuokraamo.db");

  PreparedStatement stmt = connection.prepareStatement("SELECT * FROM Pyora");
  ResultSet rs = stmt.executeQuery();

  while (rs.next()) {
  String rekisterinumero = rs.getString("rekisterinumero");
  String merkki = rs.getString("merkki");

  System.out.println(rekisterinumero + " " + merkki);
  }

  stmt.close();
  rs.close();

  connection.close();
<% end %>

<p>
  Käydään ylläoleva ohjelmakoodi läpi askeleittain.
</p>

<ol>
  <li>
    <p>Luomme ensin JDBC-yhteyden tietokantaan <em>vuokraamo.db</em>.
      <% partial 'partials/code_highlight' do %>
	Connection connection = DriverManager.getConnection("jdbc:sqlite:vuokraamo.db");
      <% end %>
    </p>
  </li>
  
  <li>
    <p>Kysely luodaan antamalla yhteydelle merkkijono, jossa on kysely. Yhteys palauttaa <em>PreparedStatement</em>-olion, jota käytetään kyselyn suorittamiseen ja tulosten pyytämiseen. Metodi <em>executeQuery</em> suorittaa SQL-kyselyn ja palauttaa tulokset sisältävän <em>ResultSet</em>-olion.
      
      <% partial 'partials/code_highlight' do %>
	PreparedStatement statement = connection.prepareStatement("SELECT * FROM Pyora");
	ResultSet resultSet = statement.executeQuery();
      <% end %>
    </p>
  </li>
  
  <li>
    <p>Tämän jälkeen ResultSet-oliossa olevat tulokset käydään läpi. Metodia next() kutsumalla siirrytään kyselyn palauttamissa tulosriveissä eteenpäin. Kultakin riviltä voi kysyä sarakeotsikon perusteella solun arvoa. Esimerkiksi kutsu getString("rekisterinumero") palauttaa kyseisellä rivillä olevan sarakkeen "rekisterinumero" arvon String-tyyppisenä.

      <% partial 'partials/code_highlight' do %>
	while(resultSet.next()) {
	String rekisterinumero = rs.getString("rekisterinumero");
	String merkki = rs.getString("merkki");

	System.out.println(rekisterinumero + " " + merkki);
	}
      <% end %>
    </p>
  </li>
  
  <li>
    <p>Kun kyselyn vastauksena saadut rivit on käyty läpi, eikä niitä enää tarvita, vapautetaan niihin liittyvät resurssit.
      
      <% partial 'partials/code_highlight' do %>
	stmt.close();
	rs.close();
      <% end %>
    </p>
  </li>


  <li>
    <p>Lopulta tietokantayhteys suljetaan.

      <% partial 'partials/code_highlight' do %>
	connection.close();
      <% end %>
    </p>
  </li>
</ol>



<% partial 'partials/material_sub_sub_heading' do %>
  Parametrien lisääminen kyselyyn
<% end %>

<p>
  Kyselyihin halutaan usein antaa rajausehtoja. Ohjelmallisesti tämä tapahtuu lisäämällä kyselyä muodostaessa rajausehtoihin kohtia, joihin asetetaan arvot. Alla olevassa esimerkissä kyselyyn lisätään merkkijono.
</p>

<% partial 'partials/code_highlight' do %>
  PreparedStatement statement = connection.prepareStatement("SELECT * FROM Pyora WHERE merkki = ?");
  statement.setString(1, "Royal Enfield");

  ResultSet resultSet = statement.executeQuery();
<% end %>

<p>
  Kyselyiden paikat indeksoidaan kohdasta 1 alkaen. Alla olevassa esimerkissä haetaan Henkilo-taulusta henkilöitä, joiden syntymävuosi on 1952.
</p>

<% partial 'partials/code_highlight' do %>
  PreparedStatement statement = connection.prepareStatement("SELECT * FROM Henkilo WHERE syntymavuosi  = ?");
  statement.setInt(1, 1952);

  ResultSet resultSet = statement.executeQuery();
<% end %>

<p>
  Ohjelma voi toimia myös siten, että rajausehdot kysytään ohjelman käyttäjältä.
</p>


<% partial 'partials/code_highlight' do %>
  Scanner lukija = new Scanner(System.in);
  System.out.println("Minkä vuoden opiskelijat tulostetaan?");
  int vuosi = Integer.parseInt(lukija.nextLine());

  // ...

  PreparedStatement statement = connection.prepareStatement("SELECT * FROM Henkilo WHERE syntymavuosi  = ?");
  statement.setInt(1, vuosi);

  ResultSet resultSet = statement.executeQuery();

  // ...
<% end %>


<% partial 'partials/hint', locals: { name: 'PreparedStatement ja set<em>Arvo</em>-metodit' } do %>

  <p>
    Kun kyselyt luodaan tietokantayhteyteen liittyvän olion prepareStatement oliolla, kyselyihin merkitään kysymysmerkeillä ne kohdat, joihin käyttäjän syöttämiä arvoja voidaan lisätä. Kun metodilla setArvo -- esim setInt -- asetetaan parametrin arvo kyselyyn, Java tarkastaa (1) että arvo on varmasti halutun kaltainen ja (2) että arvossa ei ole esimerkiksi hipsuja, joiden kautta parametri voisi vaikuttaa kyselyn tavoitteisiin.
  </p>

  <p>
    Palaamme tähän kohta SQL-injektioihin liittyvässä aliluvussa.
  </p>
  
<% end %>




<% partial 'partials/material_sub_sub_heading' do %>
  Päivityskyselyiden tekeminen
<% end %>

<p>
  Myös päivityskyselyiden kuten rivien lisäämisten ja rivien poistamisten tekeminen onnistuu ohjelmallisesti. Tällöin tuloksessa ei ole erillistä ResultSet-oliota, vaan luku, joka kertoo muuttuneiden rivien määrän. Allaoleva ohjelmakoodi lisää pyöriä sisältävään tietokantaan uuden pyörän.
</p>

<% partial 'partials/code_highlight' do %>
  Connection connection = DriverManager.getConnection("jdbc:sqlite:vuokraamo.db");

  PreparedStatement stmt = connection.prepareStatement("INSERT INTO Pyora (rekisterinumero, merkki) VALUES (?, ?)");
  stmt.setString(1, "RIP-34");
  stmt.setString(2, "Jopo");

  int changes = stmt.executeUpdate();

  System.out.println("Kyselyn vaikuttamia rivejä: " + changes);
  stmt.close();

  connection.close();
<% end %>



<% partial 'partials/material_sub_sub_heading' do %>
  SQL-injektiot
<% end %>

<p>
  Suurin osa olemassaolevista sovelluksista käyttää tietokannanhallintajärjestelmiä jollain tavalla: tietoa haetaan tietokannasta, tietokannassa olevaa tietoa muokataan, ja tietokantaan tallennetaan tietoa. Tyypillisesti sovelluksiin on myös käyttöliittymä, minkä kautta sovelluksen käyttäjät pääsevät vaikuttamaan kyselyiden sisältöön.
</p>

<p>
  SQL-injektioiden tekeminen onnistuu jos ohjelmoija jättää tietokantaa käsitteleviin kyselyihin ns. käyttäjän mentävän aukon. Tämä onnistuu Javalla siten, että kyselyt luodaan niin, että kyselyihin lisättävät parametrit syötetään kyselyyn suoraan merkkijonona.
</p>

<p>
  Alla on esimerkki, missä käyttäjältä kysytään haettavan pyörän merkkiä.
</p>

<% partial 'partials/code_highlight' do %>
  Scanner lukija = new Scanner(System.in);
  System.out.println("Minkä merkkiset pyörät tulostetaan?");
  String merkki = lukija.nextLine();

  // ...

  PreparedStatement statement = connection.prepareStatement("SELECT * FROM Pyora WHERE merkki = ?");
  statement.setString(1, merkki);

  // ...

  ResultSet resultSet = statement.executeQuery();
<% end %>

<p>
  Kysely on turvallinen, sillä merkki asetetaan metodin setString avulla. Metodi tarkastaa myös, ettei kyselyssä ole ylimääräistä sisältöä. 
</p>

<p>
  Kyselystä saa helposti erittäin turvattoman. Seuraavassa esimerkissä on mahdollisuus SQL-injektioon.
</p>

<% partial 'partials/code_highlight' do %>
  Scanner lukija = new Scanner(System.in);
  System.out.println("Minkä merkkiset pyörät tulostetaan?");
  String merkki = lukija.nextLine();

  // ...

  PreparedStatement statement = connection.prepareStatement("SELECT * FROM Pyora WHERE merkki = '" + merkki + "'");

  // ...

  ResultSet resultSet = statement.executeQuery();
<% end %>

<p>
  Kun käyttäjän syöttämä merkkijono lisätään suoraan osaksi kyselyä, voi käyttäjä syöttää SQL-lauseita komentoonsa. Jos käyttäjä syöttää ohjelmaan esimerkiksi merkkijono <code>a' OR 'a'='a</code>, on suoritettava SQL-lause lopulta muotoa:
</p>

<% partial 'partials/sql_highlight' do %>
  SELECT * FROM Pyora WHERE merkki = 'a' OR 'a'='a'
<% end %>

<p>
  Edellinen lause on aina totta, sillä tarkastus 'a'='a' on totta.
</p>

<p>
  Myös muunlaisten SQL-lauseiden suoritus olisi em. tapauksessa mahdollista. Web-sarjakuva <a href="http://xkcd.com/" target="_blank">xkcd</a> kuvastaa tätä ilmiötä hyvin <em>Exploits of a Mom</em>-sarjakuvallaan.
</p>

<figure>
  
  <img src="http://imgs.xkcd.com/comics/exploits_of_a_mom.png" alt="School: Hi, this is your son's school. We're having some computer trouble.
								    
								    Mom: Oh, dear -- Did he break something?
								    
								    School: In a way. Did you really name your son Robert'); DROP TABLE Students;--?
								    
								    Mom: Oh. Yes. Little Bobby Tables we call him.
								    
								    School: Well, we've lost this year's student records. I hope you're happy.
								    
								    Mom: And I hope you've learned to sanitize your database inputs."/>
  
  <figcaption>http://xkcd.com/327/ -- Exploits of a Mom. </figcaption>
  
</figure>





<% partial 'partials/exercise', locals: { name: 'Listaaminen ja lisääminen' } do %>

  <p>
    Luo tekstikäyttöliittymää käyttävä interaktiivinen sovellus, jossa voi listata ja lisätä kappaleita. Käytä tässä ensimmäisessä tehtävässä luomaasi tietokantaa (tai ainakin sen rakennetta). Ohjelman tulee käynnistyä kun luokassa ListaaminenJaLisaaminen oleva main-metodi suoritetaan. Ohjelman toiminnan tulee olla seuraavanlainen. Alla punaisella merkityt rivit ovat käyttäjän syöttämiä.
  </p>

  
  <% partial 'partials/sample_output' do %>
    Tervetuloa!
    Komennot:
    1: Listaa kappaleet
    2: Lisää kappale
    3: Sulje
    
    &gt; <font color="red">1</font>
    (ei kappaleita)

    &gt; <font color="red">2</font>
    Nimi: <font color="red">The Days you Didn't Notice</font>
    Artisti: <font color="red">Rendezvous Park</font>
    Levytysvuosi: <font color="red">2010</font>
    Pituus: <font color="red">605</font>

    &gt; <font color="red">2</font>
    Nimi: <font color="red">Closer To Being Here - Reprise</font>
    Artisti: <font color="red">Rendezvous Park</font>
    Levytysvuosi: <font color="red">2012</font>
    Pituus: <font color="red">363</font>

    &gt; <font color="red">1</font>
    Rendezvous Park, Closer to Being Here - Reprise (363 s), 2012
    Rendezvous Park, The Days you DIdn't Notice (605 s), 2010

    &gt; <font color="red">3</font>
  <% end %>

  <p>
    Sovelluksen tulee käyttää tietokantaa tietojen tallentamiseen ja hakemiseen. Huomaa, että sovelluksen toiminnan tulee jatkua siitä mihin se jäi. Seuraavalla käynnistyskerralla edellisellä kerralla lisättyjen kappaleiden tulee siis olla olemassa tietokannassa.
  </p>

  <% partial 'partials/sample_output' do %>
    Tervetuloa!
    Komennot:
    1: Listaa kappaleet
    2: Lisää kappale
    3: Sulje
    
    &gt; <font color="red">1</font>
    Rendezvous Park, Closer to Being Here - Reprise (363 s), 2012
    Rendezvous Park, The Days you DIdn't Notice (605 s), 2010

    &gt; <font color="red">3</font>
  <% end %>

  <p>
    <em>
      Sovelluksessa ei saa olla mahdollisuutta SQL-injektion tekemiseen.
    </em>
  </p>
  
<% end %>


<% partial 'partials/exercise', locals: { name: 'Injektio' } do %>

  <p>
    Toteuta sama sovellus kuin edellä, mutta lisää sovellukseen SQL-injektiomahdollisuus. Käyttäjän tulee siis pystyä kirjoittamaan syötteenä -- ainakin jossain kohtaa sovellusta -- SQL-koodia, joka suoritetaan tietokannassa. 
  </p>

  <p>
    Luennolla 15.9. huomattiin, että JDBC ei hyväksy useampaa lausetta samassa kyselyssä. Jos haluat sallia useamman kyselyn tekemisen, lisää tietokantayhteyden muodostamiseen parametri <code>allowMultiQueries=true</code>, esim. <code>DriverManager.getConnection("jdbc:sqlite:vuokraamo.db?allowMultiQueries=true")</code>.
  </p>

  <p>
    Tähän löytyy muutamia muitakin tapoja, kuten useamman rivin lisääminen "vahingossa" (kts. <a href="https://stackoverflow.com/questions/452859/inserting-multiple-rows-in-a-single-sql-query" target="_blank" norel>https://stackoverflow.com/questions/452859/inserting-multiple-rows-in-a-single-sql-query</a>) sekä -- todennäköisesti -- harmin aiheuttaminen alikyselyn kautta (kts. <a href="https://stackoverflow.com/questions/12467354/nesting-queries-in-sql" target="_blank" norel>https://stackoverflow.com/questions/12467354/nesting-queries-in-sql</a>).
  </p>


<% end %>



<% partial 'partials/material_heading' do %>
  Tietokantataulujen käsittely ohjelmallisesti
<% end %>


<p>
  Käsittelimme edellisessä osassa tietokantakyselyiden tekemistä ohjelmallisesti. Tietokantakyselyiden tekeminen koostuu oleellisesti muutamasta osasta: (1) yhteyden muodostaminen tietokantaan, (2) kyselyn muodostaminen, (3) kyselyn suorittaminen, (4) vastausten läpikäynti, ja (5) resurssien vapauttaminen sekä yhteyden sulkeminen. Edellisessä osassa käsiteltiin Pyora-taulun sisältävää tietokantaa seuraavasti.
</p>


<% partial 'partials/code_highlight' do %>
  Connection connection = DriverManager.getConnection("jdbc:sqlite:vuokraamo.db");

  PreparedStatement stmt = connection.prepareStatement("SELECT * FROM Pyora");
  ResultSet rs = stmt.executeQuery();

  while (rs.next()) {
      String rekisterinumero = rs.getString("rekisterinumero");
      String merkki = rs.getString("merkki");

      System.out.println(rekisterinumero + " " + merkki);
  }

  stmt.close();
  rs.close();

  connection.close();
<% end %>



<% partial 'partials/material_sub_heading' do %>
  Oliot ja tietokantataulu
<% end %>

<p>
  Ohjelmoijan näkökulmasta on paljon mielekkäämpää jos tietoa pystyy käsittelemään olioiden avulla. Oletetaan, että käytössämme on luokka Asiakas sekä tietokantataulu Asiakas. Tietokantataulu on luotu seuraavalla CREATE TABLE -lauseella.
</p>

<% partial 'partials/sql_highlight' do %>
  CREATE TABLE Asiakas (
      id integer PRIMARY KEY,
      nimi varchar(200),
      puhelinnumero varchar(20),
      katuosoite varcar(50),
      postinumero integer,
      postitoimipaikka varchar(20)
  );
<% end %>

<p>
  Alla on taulua vastaava luokka.
</p>

<% partial 'partials/code_highlight' do %>
  public class Asiakas {
      Integer id;
      String nimi;
      String puhelinnumero;
      String katuosoite;
      Integer postinumero;
      String postitoimipaikka;

      public Asiakas(Integer id, String nimi, String puhelinnumero, String
              katuosoite, Integer postinumero, String postitoimipaikka) {
          this.id = id;
          this.nimi = nimi;
          this.puhelinnumero = puhelinnumero;
          this.katuosoite = katuosoite;
          this.postinumero = postinumero;
          this.postitoimipaikka = postitoimipaikka;
      }

      // muita metodeja ym

  }
<% end %>

<p>
  Hakiessamme tietoa tietokantataulusta Asiakas voimme muuntaa kyselyn tulokset Asiakas-olioiksi.
</p>

<% partial 'partials/code_highlight' do %>
  Connection connection = DriverManager.getConnection("jdbc:sqlite:<em>tietokanta.db</em>");

  PreparedStatement stmt = connection.prepareStatement("SELECT * FROM Asiakas");
  ResultSet rs = stmt.executeQuery();

  List&lt;Asiakas&gt; asiakkaat = new ArrayList&lt;&gt;();
  
  while (rs.next()) {
      Asiakas a = new Asiakas(rs.getInt("id"), rs.getString("nimi"),
          rs.getString("puhelinnumero"), rs.getString("katuosoite"),
          rs.getInt("postinumero"), rs.getString("postitoimipaikka"));
  
      asiakkaat.add(a);
  }

  stmt.close();
  rs.close();

  connection.close();

  // nyt asiakkaat listassa
<% end %>

<p>
  Myös uuden Asiakas-olion tallentaminen tietokantatauluun onnistuu. 
</p>

<% partial 'partials/code_highlight' do %>
  Connection connection = DriverManager.getConnection("jdbc:sqlite:<em>tietokanta.db</em>");

  PreparedStatement stmt = connection.prepareStatement("INSERT INTO Asiakas"
      + " (nimi, puhelinnumero, katuosoite, postinumero, postitoimipaikka)"
      + " VALUES (?, ?, ?, ?, ?)");
  stmt.setString(1, asiakas.getNimi());
  stmt.setString(2, asiakas.getPuhelinnumero());
  stmt.setString(3, asiakas.getKatuosoite());
  stmt.setInt(4, asiakas.getPostinumero());
  stmt.setString(5, asiakas.getPostitoimipaikka());

  stmt.executeUpdate();
  stmt.close();


  // voimme halutessamme tehdä myös toisen kyselyn, jonka avulla saadaan selville
  // juuri tallennetun olion tunnus -- alla oletetaan, että asiakkaan voi
  // yksilöidä nimen ja puhelinnumeron perusteella
  stmt = connection.prepareStatement("SELECT * FROM Asiakas"
      + " WHERE nimi = ? AND puhelinnumero = ?");
  stmt.setString(1, asiakas.getNimi());
  stmt.setString(2, asiakas.getPuhelinnumero());

  ResultSet rs = stmt.executeQuery();
  rs.next(); // vain 1 tulos

  Asiakas a = new Asiakas(rs.getInt("id"), rs.getString("nimi"),
      rs.getString("puhelinnumero"), rs.getString("katuosoite"),
      rs.getInt("postinumero"), rs.getString("postitoimipaikka"));
  
  stmt.close();
  rs.close();

  connection.close();
<% end %>


<% partial 'partials/material_sub_heading' do %>
  DAO-suunnittelumalli
<% end %>

<p>
  Edellisissä esimerkeissä tietokantakyselytoiminnallisuus ja suurin osa ohjelman omasta toiminnallisuudesta on ollut samassa, mikä johtaa helposti sekavaan koodiin. Esimerkiksi tilanteessa, missä alla oleva tietokantalogiikka muuttuisi, lähes koko ohjelmaa tulisi muuttaa.
</p>

<p>
  Tietokantasovelluksia toteuttaessa on hyvin tyypillistä abstrahoida, eli piilottaa, konkreettinen tiedon hakemis- ja tallennustoiminnallisuus siten, että ohjelmoijan ei tarvitse nähdä sitä jatkuvasti. Ideana on, että sovelluskehittäjä käyttää <em>DAO</em>-rajapinnan toteuttamia olioita, ja se, että mistä tai miten tiedot konkreettisesti haetaan ei ole sovelluksen muiden osien tiedossa.
</p>

<% partial 'partials/hint', locals: { name: 'Data Access Object (DAO)' } do %>

  <p>
    Wikipedia: <em>In computer software, a data access object (DAO) is an object that provides an abstract interface to some type of database or other persistence mechanism. By mapping application calls to the persistence layer, DAO provide some specific data operations without exposing details of the database. This isolation supports the Single responsibility principle. It separates what data accesses the application needs, in terms of domain-specific objects and data types (the public interface of the DAO), from how these needs can be satisfied with a specific DBMS, database schema, etc. (the implementation of the DAO).</em>
  </p>
  
  <p>
    <em>Although this design pattern is equally applicable to the following: (1- most programming languages; 2- most types of software with persistence needs; and 3- most types of databases) it is traditionally associated with Java EE applications and with relational databases (accessed via the JDBC API because of its origin in Sun Microsystems' best practice guidelines "Core J2EE Patterns" for that platform).</em>
  </p>
<% end %>
  
<p>
  Hahmotellaan hakemiseen ja poistamiseen liittyvää rajapintaa, joka tarjoaa metodit <code>findOne</code>, <code>findAll</code>, <code>saveOrUpdate</code> ja <code>delete</code>, eli toiminnallisuudet hakemiseen, tallentamiseen ja poistamiseen. Tehdään rajapinnasta <em>geneerinen</em>, eli toteuttava luokka määrittelee palautettavien olioiden tyypin sekä avaimen.
</p>

<% partial 'partials/code_highlight' do %>
import java.sql.*;
import java.util.*;

public interface Dao&lt;T, K&gt; {
    T findOne(K key) throws SQLException;
    List&lt;T&gt; findAll() throws SQLException;
    T saveOrUpdate(T object) throws SQLException;
    void delete(K key) throws SQLException;
}
<% end %>

<p>
  Metodi findOne hakee tietyllä avaimella haettavan olion, jonka tyyppi voi olla mikä tahansa, ja metodi saveOrUpdate joko tallentaa olion tai päivittää tietokannassa olevaa oliota riippuen siitä, onko olion id-kentässä arvoa. Alustava hahmotelma konkreettisesta asiakkaiden käsittelyyn tarkoitetusta <code>AsiakasDao</code>-luokasta on seuraavanlainen.
</p>

<% partial 'partials/code_highlight' do %>
import java.util.*;
import java.sql.*;

public class AsiakasDao implements Dao&lt;Asiakas, Integer&gt; {

    @Override
    public Asiakas findOne(Integer key) throws SQLException {
        // ei toteutettu
        return null;
    }

    @Override
    public List&lt;Asiakas&gt; findAll() throws SQLException {
	// ei toteutettu
	return null;
    }

    @Override
    public Asiakas saveOrUpdate(Asiakas object) throws SQLException {
        // ei toteutettu
        return null;
    }
  
    @Override
    public void delete(Integer key) throws SQLException {
        // ei toteutettu
    }
}
<% end %>

<p>
  Käytännössä tyyppiparametrit annetaan rajapinnan toteuttamisesta kertovan avainsanan <code>implements</code>-yhteyteen. Ylläolevassa esimerkissä haettavan olion tyyppi on <code>Asiakas</code>, ja sen pääavain on tyyppiä <code>Integer</code>.
</p>

<p>
  Luodaan tietokanta-abstraktio, jolta voidaan pyytää tietokantayhteyttä tarvittaessa.
</p>

<% partial 'partials/code_highlight' do %>
  import java.sql.*;

  public class Database {

      private String databaseAddress;

      public Database(String databaseAddress) throws ClassNotFoundException {
          this.databaseAddress = databaseAddress;
      }

      public Connection getConnection() throws SQLException {
          return DriverManager.getConnection(databaseAddress);
      }
  }
<% end %>

<p>
  Jatketaan luokan <code>AsiakasDao</code> toteuttamista. Lisätään luokkaan tietokannan käyttö tietokanta-abstraktion avulla sekä asiakkaan poistaminen avaimen perusteella 
</p>

<% partial 'partials/code_highlight' do %>
import java.util.*;
import java.sql.*;

public class AsiakasDao implements Dao&lt;Asiakas, Integer&gt; {

    private Database database;

    public AsiakasDao(Database database) {
        this.database = database;
    }

    @Override
    public Asiakas findOne(Integer key) throws SQLException {
        // ei toteutettu
        return null;
    }

    @Override
    public List&lt;Asiakas&gt; findAll() throws SQLException {
	// ei toteutettu
	return null;
    }

    @Override
    public Asiakas saveOrUpdate(Asiakas object) throws SQLException {
        // ei toteutettu
        return null;
    }
  
    @Override
    public void delete(Integer key) throws SQLException {
        Connection conn = database.getConnection();
        PreparedStatement stmt = conn.prepareStatement("DELETE FROM Asiakas WHERE id = ?");

        stmt.setInt(1, key);
        stmt.executeUpdate();

        stmt.close();
        conn.close();
    }
}
<% end %>
  
<p>
  Vastaavasti yksittäisen asiakkaan noutaminen onnistuisi findOne-metodilla.
</p>

<% partial 'partials/code_highlight' do %>
import java.util.*;
import java.sql.*;

public class AsiakasDao implements Dao&lt;Asiakas, Integer&gt; {

    private Database database;

    public AsiakasDao(Database database) {
        this.database = database;
    }

    @Override
    public Asiakas findOne(Integer key) throws SQLException {
        Connection conn = database.getConnection();
        PreparedStatement stmt = conn.prepareStatement("SELECT * FROM Asiakas WHERE id = ?");
        stmt.setInt(1, key);

        ResultSet rs = stmt.executeQuery();
        boolean hasOne = rs.next();
        if (!hasOne) {
            return null;
        }

        Asiakas a = new Asiakas(rs.getInt("id"), rs.getString("nimi"),
            rs.getString("puhelinnumero"), rs.getString("katuosoite"),
            rs.getInt("postinumero"), rs.getString("postitoimipaikka"));
  
        stmt.close();
        rs.close();

        conn.close();

        return a;
    }

    @Override
    public List&lt;Asiakas&gt; findAll() throws SQLException {
	// ei toteutettu
	return null;
    }

    @Override
    public Asiakas saveOrUpdate(Asiakas object) throws SQLException {
        // ei toteutettu
        return null;
    }
  
    @Override
    public void delete(Integer key) throws SQLException {
        Collection conn = database.getConnection();
        PreparedStatement stmt = conn.prepareStatement("DELETE FROM Asiakas WHERE id = ?");

        stmt.setInt(1, key);
        stmt.executeUpdate();

        stmt.close();
        conn.close();
    }
}
<% end %>

<p>
  Ja niin edelleen. Nyt asiakkaiden muokkaaminen on DAO-rajapintaa käyttävän ohjelman näkökulmasta hieman helpompaa.
</p>

<% partial 'partials/code_highlight' do %>
  Database database = new Database("jdbc:sqlite:kanta.db");
  AsiakasDao asiakkaat = new AsiakasDao(database);

  Scanner lukija = new Scanner(System.in);

  System.out.println("Millä tunnuksella asiakasta haetaan?");
  int tunnus = Integer.parseInt(lukija.nextLine());

  Asiakas a = asiakkaat.findOne(tunnus);

  System.out.println("Asiakas: " + a);
<% end %>



<% partial 'partials/material_sub_heading' do %>
  Viitteet olioiden välillä
<% end %>

<p>
  Edellisessä esimerkissä käsittelimme yksittäistä oliota, josta ei ole viitteitä muihin käsitteisiin. Hahmotellaan seuraavaksi Tilaus-käsitteen käsittelyä ohjelmallisesti. Luodaan ensin Tilausta kuvaava luokka ja toteutetaan tämän jälkeen tilausten tallennuksesta ja käsittelystä vastaava DAO-luokka.
</p>


<% partial 'partials/code_highlight' do %>
  public class Tilaus {
      Integer id;
      Asiakas asiakas;
      Date aika;
      String kuljetustapa;
      Boolean vastaanotettu;
      Boolean toimitettu;

      // konstruktorit sekä getterit ja setterit

  }
<% end %>

<p>
  Toteutetaan tilausten käsittelyyn tarkoitettu DAO-luokka siten, että se saa konstruktorissaan sekä viitteen tietokanta-olioon että viitteen asiakkaiden hakemiseen tarkoitettuun Dao-rajapintaan.
</p>

<% partial 'partials/code_highlight' do %>
import java.util.*;
import java.sql.*;

public class TilausDao implements Dao&lt;Tilaus, Integer&gt; {


    private Database database;
    private Dao&lt;Asiakas, Integer&gt; asiakasDao;

    public TilausDao(Database database, Dao&lt;Asiakas, Integer&gt; asiakasDao) {
        this.database = database;
        this.asiakasDao = asiakasDao;
    }

    @Override
    public Tilaus findOne(Integer key) throws SQLException {
        Connection connection = database.getConnection();
        PreparedStatement stmt = connection.prepareStatement("SELECT * FROM Tilaus WHERE id = ?");
        stmt.setObject(1, key);

        ResultSet rs = stmt.executeQuery();
        boolean hasOne = rs.next();
        if (!hasOne) {
            return null;
        }

        Asiakas asiakas = asiakasDao.findOne(rs.getInt("asiakas_id"));

        Tilaus t = new Tilaus(key, asiakas,
            rs.getDate("aika"), rs.getString("kuljetustapa"),
            rs.getBoolean("vastaanotettu"), rs.getBoolean("toimitettu"));


        rs.close();
        stmt.close();
        connection.close();

        return t;
    }

    @Override
    public List&lt;Tilaus&gt; findAll() throws SQLException {
	// ei toteutettu
	return null;
    }


    @Override
    public Tilaus saveOrUpdate(Tilaus object) throws SQLException {
	// ei toteutettu
	return null;
    }

    @Override
    public void delete(Integer key) throws SQLException {
        // ei toteutettu
    }
}
<% end %>

<p>
  Nyt yksittäisen tilauksen hakemisen yhteydessä palautetaan sekä tilaus, että siihen liittyvä asiakas. Rajapintaa käyttävän toteutuksen näkökulmasta tietokannan käyttäminen toimii seuraavasti:
</p>


<% partial 'partials/code_highlight' do %>
Database database = new Database("jdbc:sqlite:kanta.db");
AsiakasDao asiakkaat = new AsiakasDao(database);
TilausDao tilaukset = new TilausDao(database, asiakkaat);

Tilaus t = tilaukset.findOne(4);
System.out.println("Tilauksen teki: " + t.getAsiakas().getNimi());
<% end %>
  


<% partial 'partials/hint', locals: { name: 'Mitä tietokannasta pitäisi noutaa?' } do %>

  <p>
    Kun jatkamme edellistä esimerkkiä, pitäisikö annosta haettaessa hakea aina siihen liittyvä ravintola? Entä pitääkö tilausta haettaessa oikeasti hakea myös tilaukseen liittyvä asiakas?
  </p>
  
  <p>
    Hyvä kysymys. Kun tietokantataulujen välisten yhteyksien perusteella tehdään uusia kyselyitä tietokantaan, olemassa on oleellisesti kaksi vaihtoehtoa sekä niiden seuraukset: (1) haetaan liikaa tietoa, jolloin hakemisoperaatioon menee turhaan aikaa, tai (2) haetaan liian vähän tietoa, jolloin tieto tulee hakea myöhemmin.
  </p>

  <p>
    Yksi tapa ratkaista ongelma on toimia siten, että tietoa haetaan vain silloin kun sitä tarvitaan. Tällöin esimerkiksi vasta Tilaus-olioon mahdollisesti liittyvää <code>getAsiakas</code>-metodia kutsuttaessa asiakkaaseen liittyvät tiedot haettaisiin tietokannasta -- getAsiakas-metodi tekisi siis tietokantahaun. Tämäkään ei kuitenkaan ratkaise tilannetta, sillä jos tavoitteenamme olisi vaikkapa tulostaa kaikki tilaukset ja niihin liittyvät asiakkaat -- edellisellä lähestymistavalla kaksi tietokantakyselyä -- saattaisi toteutus lopulta tehdä jokaisen tilauksen ja asiakkaan kohdalla oman erillisen tietokantahaun.
  </p>

  <p>
    Tähän ei ole suoraviivaista ratkaisua. Tyypillisesti Dao-rajapinnan määrittelemille metodeille kerrotaan, tuleeko haettaviin olioihin liittyvät viitteet hakea erikseen.
  </p>

<% end %>

<% partial 'partials/exercise', locals: { name: 'Asiakkaat ja tilaukset' } do %>

  <p>
    Tehtäväpohjassa on mukana edellisessä esimerkeissä luodut AsiakasDao ja TilausDao sekä niihin liittyvät luokat. Täydennä Dao-luokkien metodit siten, että jokainen metodi toimii toivotusti. Tehtäväpohjassa olevassa <code>db</code> kansiossa on mukana myös on mukana myös tiedosto <code>tilauskanta.db</code>, johon tietokannan taulut ovat luotuna. Lisää tietokantaan tarvitsemaasi testidataa.
  </p>

  <p>
    Kun Dao-luokkien metodit toimivat oikein, palauta tehtävä TMC:lle.
  </p>
  
<% end %>


<%= partial 'partials/quiz', locals: { id: '59c3efb181c8a0000400617e' } %>
